# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:

        def dfs(root, lower_bound, upper_bound):
            if(not root):
                return True

            if(not lower_bound < root.val < upper_bound):
                return False

            left = dfs(root.left, lower_bound, root.val)
            right = dfs(root.right, root.val, upper_bound)

            return left and right


        return dfs(root, float('-inf'), float('inf'))

"""
Date: 27th Jan 2026
Mistake:
- Came up with below soln, but made a very common mistake, of only comparing with neighbours and not keeping track of the above root nodes
- above soln is a common way of solving BSTs




"""
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:

        if(not root):
            return True

        left = self.isValidBST(root.left)
        right = self.isValidBST(root.right)

        valid = True
        if(root.left):
            if(root.left.val >= root.val):
                valid = False
        if(root.right):
            if(root.right.val <= root.val):
                valid = False
            
        return left and right and valid

This soln fails at root = [5,4,6,null,null,3,7]
"""
